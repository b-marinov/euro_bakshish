# Migration Guide: Django + React → NextPy

This document explains the migration from the previous Django + React + Android stack to the new NextPy-based architecture.

## Why the Migration?

The previous architecture was complex with:
- **3 separate codebases** (Django, React, Android)
- **Multiple languages** (Python, JavaScript, Kotlin)
- **Complex deployment** (3 different deployment processes)
- **Maintenance overhead** (keeping 3 stacks updated)

The new NextPy architecture offers:
- **Single codebase** - Everything in one Python file
- **Single language** - Pure Python for everything
- **Simple deployment** - Just run one Python app
- **Reduced complexity** - No JavaScript, no mobile app, just Python

## Architecture Comparison

### Old Stack
```
Frontend (React) ←→ Backend (Django) ←→ Database (PostgreSQL)
     ↓
Android App (Kotlin)
```

### New Stack
```
NextPy Application (Python)
   ├─ Frontend (React via Python)
   ├─ Backend (FastAPI)
   └─ Database (SQLite/PostgreSQL)
```

## Key Changes

### 1. Models
**Before (Django):**
```python
# backend/apps/users/models.py
from django.db import models

class User(AbstractUser):
    user_type = models.CharField(max_length=10)
    # ... more fields
```

**After (NextPy/SQLModel):**
```python
# euro_bakshish_app.py
from sqlmodel import Field, SQLModel

class User(SQLModel, table=True):
    user_type: str = Field(default="passenger")
    # ... more fields
```

### 2. API Endpoints
**Before (Django REST Framework):**
```python
# backend/apps/users/views.py
from rest_framework import viewsets

class UserViewSet(viewsets.ModelViewSet):
    queryset = User.objects.all()
    serializer_class = UserSerializer
```

**After (NextPy - Automatic):**
```python
# API endpoints are automatically generated by NextPy
# based on the State class methods
class State(xt.State):
    def login(self): ...
    def register(self): ...
```

### 3. Frontend Components
**Before (React + JavaScript):**
```javascript
// web/src/pages/Login.js
import React from 'react';

function Login() {
  return (
    <div>
      <input placeholder="Username" />
      <button onClick={handleLogin}>Login</button>
    </div>
  );
}
```

**After (NextPy - Python):**
```python
# euro_bakshish_app.py
def login_page() -> xt.Component:
    return xt.vstack(
        xt.input(placeholder="Username", value=State.username),
        xt.button("Login", on_click=State.login),
    )
```

### 4. State Management
**Before (Redux):**
```javascript
// web/src/redux/slices/authSlice.js
const authSlice = createSlice({
  name: 'auth',
  initialState: { user: null },
  reducers: { ... }
});
```

**After (NextPy State):**
```python
# euro_bakshish_app.py
class State(xt.State):
    current_user: Optional[dict] = None
    logged_in: bool = False
```

## Feature Parity

All features from the original application are maintained:

| Feature | Old Stack | New Stack | Status |
|---------|-----------|-----------|--------|
| User Registration | ✓ | ✓ | ✓ Complete |
| User Login | ✓ | ✓ | ✓ Complete |
| Trip Creation | ✓ | ✓ | ✓ Complete |
| Trip Acceptance | ✓ | ✓ | ✓ Complete |
| Trip History | ✓ | ✓ | ✓ Complete |
| Rating System | ✓ | ✓ | ✓ Complete |
| Android App | ✓ | ✗ | Removed (per requirements) |

## Running the New Application

### Quick Start
```bash
# Install dependencies
pip install -r requirements-nextpy.txt

# Run the application
python euro_bakshish_app.py

# Access at http://localhost:3000
```

### Database
The new application uses SQLite by default but can be configured to use PostgreSQL:

```python
# In euro_bakshish_app.py, change:
DATABASE_URL = "postgresql://user:pass@localhost/euro_bakshish"
```

## Development Workflow

### Old Workflow
```bash
# Start backend
cd backend && python manage.py runserver

# Start frontend (separate terminal)
cd web && npm start

# Start Android app (Android Studio)
```

### New Workflow
```bash
# Start everything
python euro_bakshish_app.py
```

That's it! One command for everything.

## Benefits of the Migration

1. **Simplified Development**
   - Single language (Python)
   - No context switching between languages
   - Unified tooling and dependencies

2. **Reduced Complexity**
   - One codebase instead of three
   - No separate API integration needed
   - Automatic API generation

3. **Easier Deployment**
   - Single Python application
   - No separate frontend build process
   - Simpler hosting requirements

4. **Better Maintainability**
   - Less code to maintain
   - Unified testing framework
   - Single dependency management

5. **Type Safety**
   - Pydantic models ensure data validation
   - Python type hints throughout
   - Compile-time error catching

## Migration Checklist for Developers

If you were working on the old codebase:

- [x] Android app removed (per requirements)
- [x] Django backend → NextPy/SQLModel
- [x] React frontend → NextPy UI components
- [x] Redux state → NextPy State
- [x] JWT auth → Session-based auth
- [x] PostgreSQL → SQLite (default, configurable)
- [ ] API tests → NextPy tests (to be added)
- [ ] Frontend tests → NextPy tests (to be added)

## Getting Help

- NextPy Documentation: https://nextpy-framework.readthedocs.io/
- NextPy GitHub: https://github.com/dot-agent/nextpy
- Project Issues: Use GitHub Issues for questions

## Future Enhancements

The new architecture makes it easier to add:
- AI/LLM features (NextPy has built-in support)
- Real-time features (WebSocket support)
- Additional integrations (simpler API)
- Progressive Web App capabilities
